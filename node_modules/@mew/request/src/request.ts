import {AxiosInstance, AxiosRequestConfig, Method} from "axios";

import * as CryptoJS from 'crypto-js'

export interface IRes<T = any> {
    code: number
    msg: string
    data: T
    total?: number
    error?: string
}

export interface IResType<T = any> {
    code: number
    msg: string
    data: T[]
    total?: number
    error?: string
}




interface IInstanceInterceptors {
    requestInterceptor?: (config: AxiosRequestConfig) => AxiosRequestConfig
    requestInterceptorCatch?: (err: any) => any
    responseInterceptor?: (res: any) => any
    responseInterceptorCatch?: (err: any) => any
}

interface IRequestConfig extends AxiosRequestConfig {
    interceptors?: IInstanceInterceptors
}

/**
 * 请求用类来集成
 */
export class Request<T, I, D, U, S> {
    private _uri: string
    private _service: any
    private _isDebugMode: boolean
    private _timeout: number
    private _isAesToStr: boolean



    constructor(uri: string, service: any, isDebugMode: boolean = false, isAesToStr = false, timeout: number = 10000) {
        this._uri = uri
        this._service = service
        this._isDebugMode = isDebugMode
        this._timeout = timeout
        this._isAesToStr = isAesToStr

        // // 请求拦截器
        // this._service.interceptors.request.use(
        //   (config) => {
        //       return config
        //   },
        //   (err) => {
        //       return err
        //   }
        // )
        // 响应拦截器
        this._service.interceptors.response.use(
          (response) => {
              return response
          },
          (err) => {
              if (err.response && err.response.status === 401){
                  return {
                      data:{
                          code:401,
                          error:"验证失效，请重新登录",
                          data:[]
                      }
                  }
              } else if (err.response && err.response.status === 403){
                  return {
                      data:{
                          code:403,
                          error:"请求被拒绝",
                          data:[]
                      }
                  }
              } else if (err.response && err.response.status === 400){
                  return  {
                      data:{
                          code:400,
                          error:"无法解析格式",
                          data:[]
                      }
                  }
              }else if (err.response && err.response.status === 500){
                  return {
                      data:{
                          code:500,
                          error:"服务器异常",
                          data:[]
                      }
                  }
              }else if (err.response && err.response.status === 502){
                  return {
                      data:{
                          code:502,
                          error:"服务器无响应",
                          data:[]
                      }
                  }
              }else if (err.response && err.response.status === 503){
                  return {
                      data:{
                          code:503,
                          error:"服务器无法使用",
                          data:[]
                      }
                  }
              }else if (err.code === "ECONNABORTED" && err.message.includes('timeout')){
                  return {
                      data:{
                          code:'10101010',
                          error:"请求超时",
                          data:[]
                      }
                  }
              }
              else {
                  return Promise.reject(err);
              }
          }
        )

        // 实例
        // this._service.interceptors.request.use(
        //   service.interceptors?.requestInterceptor,
        //   service.interceptors?.requestInterceptorCatch
        // )
        //
        // this._service.interceptors.response.use(
        //   service.interceptors?.responseInterceptor,
        //   service.interceptors?.responseInterceptorCatch
        // )

    }

    async insert(params: I): Promise<IResType<T>> {
        return await mewMsPost(this._uri + '/insert', params, this._service, this._isDebugMode,this._isAesToStr, this._timeout)
    }

    async delete(params: D): Promise<IResType<T>> {
        return await mewMsDelete(this._uri + '/delete', params, this._service, this._isDebugMode,this._isAesToStr, this._timeout)
    }

    /**
     * 用于dingtalk小程序
     * remove 相当于 post /xc/xxx/delete
     * @param params
     */
    async remove(params: D): Promise<IResType<T>> {
        return await mewMsRemove(this._uri + '/delete', params, this._service, this._isDebugMode,this._isAesToStr, this._timeout)
    }

    async update(params: U): Promise<IResType<T>> {
        return await mewMsPost(this._uri + '/update', params, this._service, this._isDebugMode,this._isAesToStr, this._timeout)
    }

    async find(params: S): Promise<IResType<T>> {
        return await mewMsPost(this._uri + '/find', params, this._service, this._isDebugMode,this._isAesToStr, this._timeout)
    }

    async select(params: S): Promise<IResType<T>> {
        return await mewMsPost(this._uri + '/select', params, this._service, this._isDebugMode,this._isAesToStr, this._timeout)
    }
}

/**
 * 米鸥科技封装-微服务Post请求
 * @param url
 * @param params
 * @param service
 * @param isDebugMode
 * @param timeout
 * @param isAesToStr
 */
export async function mewMsPost<T>(url: string, params: any = {}, service: any, isDebugMode: boolean = false,isAesToStr=false, timeout: number = 10000) {
    return await mewMsRequest<T>(url, params, 'POST', service, isDebugMode,isAesToStr, timeout)
}

/**
 * 米鸥科技封装-微服务Get请求
 * @param url
 * @param params
 * @param service
 * @param isDebugMode
 * @param timeout
 * @param isAesToStr
 */
export async function mewMsGet<T>(url: string, params: {} = {}, service: any, isDebugMode: boolean = false, timeout: number = 1000,isAesToStr=false) {
    return await mewMsRequest<T>(url, params, 'GET', service, isDebugMode,isAesToStr, timeout)
}

/**
 * 米鸥科技封装-微服务Put请求
 * @param url
 * @param params
 * @param service
 * @param isDebugMode
 * @param timeout
 * @param isAesToStr
 */
export async function mewMsPut<T>(url: string, params: {} = {}, service: any, isDebugMode: boolean = false, timeout: number = 10000,isAesToStr=false) {
    return await mewMsRequest<T>(url, params, 'PUT', service, isDebugMode,isAesToStr, timeout)
}

/**
 * 米鸥科技封装-微服务Delete请求
 * @param url
 * @param params
 * @param service
 * @param isDebugMode
 * @param timeout
 * @param isAesToStr
 */
export async function mewMsDelete<T>(url: string, params: any = {}, service: any, isDebugMode: boolean = false,isAesToStr=false, timeout: number = 10000) {
    return await mewMsRequest<T>(url, params, 'POST', service, isDebugMode,isAesToStr, timeout)
}

/**
 * 米鸥科技封装-微服务Delete请求-用于dingtalk小程序-相当于 post /xc/xxx/delete
 * @param url
 * @param params
 * @param service
 * @param isDebugMode
 * @param timeout
 * @param isAesToStr
 */
export async function mewMsRemove<T>(url: string, params: any = {}, service: any, isDebugMode: boolean = false,isAesToStr=false, timeout: number = 10000) {
    return await mewMsRequest<T>(url, params, 'POST', service, isDebugMode,isAesToStr, timeout)
}

/**
 * 米鸥科技封装-微服务Request请求
 * @param url
 * @param params
 * @param method
 * @param service
 * @param isDebugMode
 * @param timeout
 * @param isAesToStr
 */
export async function mewMsRequest<T>(url: string, params: {} = {}, method: Method = 'POST', service: any, isDebugMode: boolean = false,isAesToStr=false, timeout: number = 10000): Promise<IResType<T>> {
    const res = await mewRequest(url, params, method, service, isDebugMode,isAesToStr, timeout)
    if (res && res.code === 0) {
        return res
    } else {
        throw new Error(res?.error)
    }
}

/**
 * 米鸥科技封装Request请求
 * @param url BaseURL+uri
 * @param params
 * @param method
 * @param service
 * @param timeout
 * @param isDebugMode true:调试模式 false:正常模式(默认)
 * @param isAesToStr
 */
export async function mewRequest(url: string, params: {} = {}, method: Method = 'POST', service: any, isDebugMode: boolean = false,isAesToStr=false, timeout: number = 10000) {
    try {
        // if (service.interceptors?.requestInterceptor) {
        //     service = service.interceptors.requestInterceptor(service)
        // }

        // 传参数据加密
        let cryptoJSStr = {}
        // console.log("request传参",params);
        if (isAesToStr === true){

            if (Object.keys(params).length){
                const dataStr = JSON.stringify(params)
                // 加密data
                const cryptoData = CryptoJS.AES.encrypt(CryptoJS.enc.Utf8.parse(dataStr), CryptoJS.enc.Utf8.parse('asdfghjklzxcvbnn'), {
                    mode: CryptoJS.mode.ECB,
                    padding: CryptoJS.pad.Pkcs7
                })
                cryptoJSStr = {data:cryptoData.toString()}
            }else {
                cryptoJSStr = {}
            }

        }
        else {
            cryptoJSStr = params
        }
        // console.log("AES加密",cryptoJSStr);
        const config: AxiosRequestConfig = {
            url: url,
            method: method,
            data: cryptoJSStr,
            timeout
        }
        if (isDebugMode) console.log(config)
        const res = await service.request(config)
        if (isDebugMode) console.log(url,res)
        return res.data
    } catch (error) {
        console.log(service.defaults.baseURL + url, JSON.stringify(params), error)
        throw new Error(error)
    }
}
